// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CIM.Def.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CIM_2eDef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CIM_2eDef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CIM_2eDef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CIM_2eDef_2eproto {
  static const uint32_t offsets[];
};
namespace CIM {
namespace Def {
class CIMChannelInfo;
struct CIMChannelInfoDefaultTypeInternal;
extern CIMChannelInfoDefaultTypeInternal _CIMChannelInfo_default_instance_;
class CIMContactSessionInfo;
struct CIMContactSessionInfoDefaultTypeInternal;
extern CIMContactSessionInfoDefaultTypeInternal _CIMContactSessionInfo_default_instance_;
class CIMMsgInfo;
struct CIMMsgInfoDefaultTypeInternal;
extern CIMMsgInfoDefaultTypeInternal _CIMMsgInfo_default_instance_;
class CIMUserInfo;
struct CIMUserInfoDefaultTypeInternal;
extern CIMUserInfoDefaultTypeInternal _CIMUserInfo_default_instance_;
}  // namespace Def
}  // namespace CIM
PROTOBUF_NAMESPACE_OPEN
template<> ::CIM::Def::CIMChannelInfo* Arena::CreateMaybeMessage<::CIM::Def::CIMChannelInfo>(Arena*);
template<> ::CIM::Def::CIMContactSessionInfo* Arena::CreateMaybeMessage<::CIM::Def::CIMContactSessionInfo>(Arena*);
template<> ::CIM::Def::CIMMsgInfo* Arena::CreateMaybeMessage<::CIM::Def::CIMMsgInfo>(Arena*);
template<> ::CIM::Def::CIMUserInfo* Arena::CreateMaybeMessage<::CIM::Def::CIMUserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CIM {
namespace Def {

enum CIMCmdID : int {
  kCIM_CID_UNKNOWN = 0,
  kCIM_CID_LOGIN_AUTH_TOKEN_REQ = 257,
  kCIM_CID_LOGIN_AUTH_TOKEN_RSP = 258,
  kCIM_CID_LOGIN_AUTH_LOGOUT_REQ = 259,
  kCIM_CID_LOGIN_AUTH_LOGOUT_RSP = 260,
  kCIM_CID_LOGIN_HEARTBEAT = 261,
  kCIM_CID_LOGIN_AUTH_REQ = 263,
  kCIM_CID_LOGIN_AUTH_RSP = 264,
  kCIM_CID_LIST_RECENT_CONTACT_SESSION_REQ = 513,
  kCIM_CID_LIST_RECENT_CONTACT_SESSION_RSP = 514,
  kCIM_CID_LIST_MSG_REQ = 517,
  kCIM_CID_LIST_MSG_RSP = 518,
  kCIM_CID_MSG_DATA = 769,
  kCIM_CID_MSG_DATA_ACK = 770,
  kCIM_CID_MSG_READ_ACK = 771,
  kCIM_CID_MSG_READ_NOTIFY = 772,
  kCIM_CID_MSG_GET_LATEST_MSG_ID_REQ = 773,
  kCIM_CID_MSG_GET_LATEST_MSG_ID_RSP = 774,
  kCIM_CID_MSG_GET_BY_MSG_ID_REQ = 775,
  kCIM_CID_MSG_GET_BY_MSG_ID_RSP = 776,
  kCIM_CID_VOIP_INVITE_REQ = 1025,
  kCIM_CID_VOIP_INVITE_REPLY = 1026,
  kCIM_CID_VOIP_INVITE_REPLY_ACK = 1027,
  kCIM_CID_VOIP_HEARTBEAT = 1028,
  kCIM_CID_VOIP_BYE_REQ = 1029,
  kCIM_CID_VOIP_BYE_RSP = 1030,
  kCIM_CID_VOIP_BYE_NOTIFY = 1031,
  kCIM_CID_GROUP_CREATE_DEFAULT_REQ = 1281,
  kCIM_CID_GROUP_CREATE_DEFAULT_RSP = 1282,
  kCIM_CID_GROUP_DISBINGDING_REQ = 1283,
  kCIM_CID_GROUP_DISBINGDING_RSP = 1284,
  kCIM_CID_GROUP_EXIT_REQ = 1285,
  kCIM_CID_GROUP_EXIT_RSP = 1286,
  kCIM_CID_GROUP_LIST_REQ = 1287,
  kCIM_CID_GROUP_LIST_RSP = 1288,
  kCIM_CID_GROUP_INFO_REQ = 1289,
  kCIM_CID_GROUP_INFO_RSP = 1296,
  kCIM_CID_GROUP_INVITE_MEMBER_REQ = 1297,
  kCIM_CID_GROUP_INVITE_MEMBER_RSP = 1298,
  kCIM_CID_GROUP_KICK_OUT_MEMBER_REQ = 1299,
  kCIM_CID_GROUP_KICK_OUT_MEMBER_RSP = 1300,
  kCIM_CID_GROUP_MEMBER_CHANGED_NOTIFY = 1301,
  kCIM_CID_GROUP_LIST_MEMBER_REQ = 1302,
  kCIM_CID_GROUP_LIST_MEMBER_RSP = 1303,
  kCIM_CID_FRIEND_QUERY_USER_LIST_REQ = 1537,
  kCIM_CID_FRIEND_QUERY_USER_LIST_RSP = 1538,
  CIMCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMCmdID_IsValid(int value);
constexpr CIMCmdID CIMCmdID_MIN = kCIM_CID_UNKNOWN;
constexpr CIMCmdID CIMCmdID_MAX = kCIM_CID_FRIEND_QUERY_USER_LIST_RSP;
constexpr int CIMCmdID_ARRAYSIZE = CIMCmdID_MAX + 1;

const std::string& CIMCmdID_Name(CIMCmdID value);
template<typename T>
inline const std::string& CIMCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMCmdID_Name.");
  return CIMCmdID_Name(static_cast<CIMCmdID>(enum_t_value));
}
bool CIMCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMCmdID* value);
enum CIMIntenralCmdID : int {
  kCIM_SID_UNKNOWN = 0,
  kCIM_SID_DB_VALIDATE_REQ = 1793,
  kCIM_SID_DB_VALIDATE_RSP = 1794,
  CIMIntenralCmdID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMIntenralCmdID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMIntenralCmdID_IsValid(int value);
constexpr CIMIntenralCmdID CIMIntenralCmdID_MIN = kCIM_SID_UNKNOWN;
constexpr CIMIntenralCmdID CIMIntenralCmdID_MAX = kCIM_SID_DB_VALIDATE_RSP;
constexpr int CIMIntenralCmdID_ARRAYSIZE = CIMIntenralCmdID_MAX + 1;

const std::string& CIMIntenralCmdID_Name(CIMIntenralCmdID value);
template<typename T>
inline const std::string& CIMIntenralCmdID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMIntenralCmdID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMIntenralCmdID_Name.");
  return CIMIntenralCmdID_Name(static_cast<CIMIntenralCmdID>(enum_t_value));
}
bool CIMIntenralCmdID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMIntenralCmdID* value);
enum CIMErrorCode : int {
  kCIM_ERR_UNKNOWN = 0,
  kCIM_ERR_SUCCESS = 200,
  kCIM_ERR_INTERNAL_ERROR = 201,
  kCIM_ERR_LOGIN_DB_VALIDATE_FAILED = 2000,
  kCIM_ERR_LOGIN_VERSION_TOO_OLD = 2001,
  kCIM_ERR_LOGIN_INVALID_USER_TOKEN = 2002,
  kCIM_ERR_LOGIN_INVALID_USER_OR_PWD = 2003,
  kCIM_ERROR_USER_ALREADY_EXIST = 9000,
  kCIM_ERROR_USER_INVALID_PARAMETER = 9001,
  kCIM_ERROR_USER_NOT_EXIST = 9002,
  CIMErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMErrorCode_IsValid(int value);
constexpr CIMErrorCode CIMErrorCode_MIN = kCIM_ERR_UNKNOWN;
constexpr CIMErrorCode CIMErrorCode_MAX = kCIM_ERROR_USER_NOT_EXIST;
constexpr int CIMErrorCode_ARRAYSIZE = CIMErrorCode_MAX + 1;

const std::string& CIMErrorCode_Name(CIMErrorCode value);
template<typename T>
inline const std::string& CIMErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMErrorCode_Name.");
  return CIMErrorCode_Name(static_cast<CIMErrorCode>(enum_t_value));
}
bool CIMErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMErrorCode* value);
enum CIMClientType : int {
  kCIM_CLIENT_TYPE_DEFAULT = 0,
  kCIM_CLIENT_TYPE_ANDROID = 1,
  kCIM_CLIENT_TYPE_IOS = 2,
  kCIM_CLIENT_TYPE_WEB = 3,
  kCIM_CLIENT_TYPE_REST_API = 4,
  kCIM_CLIENT_TYPE_PC_WINDOWS = 5,
  kCIM_CLIENT_TYPE_MAC_OS = 6,
  CIMClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMClientType_IsValid(int value);
constexpr CIMClientType CIMClientType_MIN = kCIM_CLIENT_TYPE_DEFAULT;
constexpr CIMClientType CIMClientType_MAX = kCIM_CLIENT_TYPE_MAC_OS;
constexpr int CIMClientType_ARRAYSIZE = CIMClientType_MAX + 1;

const std::string& CIMClientType_Name(CIMClientType value);
template<typename T>
inline const std::string& CIMClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMClientType_Name.");
  return CIMClientType_Name(static_cast<CIMClientType>(enum_t_value));
}
bool CIMClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMClientType* value);
enum CIMSessionType : int {
  kCIM_SESSION_TYPE_Invalid = 0,
  kCIM_SESSION_TYPE_SINGLE = 1,
  kCIM_SESSION_TYPE_GROUP = 2,
  CIMSessionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMSessionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMSessionType_IsValid(int value);
constexpr CIMSessionType CIMSessionType_MIN = kCIM_SESSION_TYPE_Invalid;
constexpr CIMSessionType CIMSessionType_MAX = kCIM_SESSION_TYPE_GROUP;
constexpr int CIMSessionType_ARRAYSIZE = CIMSessionType_MAX + 1;

const std::string& CIMSessionType_Name(CIMSessionType value);
template<typename T>
inline const std::string& CIMSessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMSessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMSessionType_Name.");
  return CIMSessionType_Name(static_cast<CIMSessionType>(enum_t_value));
}
bool CIMSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMSessionType* value);
enum CIMMsgType : int {
  kCIM_MSG_TYPE_UNKNOWN = 0,
  kCIM_MSG_TYPE_TEXT = 1,
  kCIM_MSG_TYPE_FILE = 2,
  kCIM_MSG_TYPE_IMAGE = 3,
  kCIM_MSG_TYPE_AUDIO = 4,
  kCIM_MSG_TYPE_VIDEO = 5,
  kCIM_MSG_TYPE_LOCATION = 6,
  kCIM_MSG_TYPE_ROBOT = 7,
  kCIM_MSG_TYPE_TIPS = 8,
  kCIM_MSG_TYPE_NOTIFACATION = 9,
  kCIM_MSG_TYPE_AVCHAT = 10,
  CIMMsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMMsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMMsgType_IsValid(int value);
constexpr CIMMsgType CIMMsgType_MIN = kCIM_MSG_TYPE_UNKNOWN;
constexpr CIMMsgType CIMMsgType_MAX = kCIM_MSG_TYPE_AVCHAT;
constexpr int CIMMsgType_ARRAYSIZE = CIMMsgType_MAX + 1;

const std::string& CIMMsgType_Name(CIMMsgType value);
template<typename T>
inline const std::string& CIMMsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMMsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMMsgType_Name.");
  return CIMMsgType_Name(static_cast<CIMMsgType>(enum_t_value));
}
bool CIMMsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMMsgType* value);
enum CIMMsgStatus : int {
  kCIM_MSG_STATUS_NONE = 0,
  kCIM_MSG_STATUS_UNREAD = 1,
  kCIM_MSG_STATUS_READ = 2,
  kCIM_MSG_STATUS_DELETED = 3,
  kCIM_MSG_STATUS_SENDING = 4,
  kCIM_MSG_STATUS_SENT = 5,
  kCIM_MSG_STATUS_RECEIPT = 6,
  kCIM_MSG_STATUS_DRAFT = 7,
  kCIM_MSG_STATUS_SendCacel = 8,
  kCIM_MSG_STATUS_REFUSED = 9,
  kCIM_MSG_STATUS_FAILED = 10,
  CIMMsgStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMMsgStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMMsgStatus_IsValid(int value);
constexpr CIMMsgStatus CIMMsgStatus_MIN = kCIM_MSG_STATUS_NONE;
constexpr CIMMsgStatus CIMMsgStatus_MAX = kCIM_MSG_STATUS_FAILED;
constexpr int CIMMsgStatus_ARRAYSIZE = CIMMsgStatus_MAX + 1;

const std::string& CIMMsgStatus_Name(CIMMsgStatus value);
template<typename T>
inline const std::string& CIMMsgStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMMsgStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMMsgStatus_Name.");
  return CIMMsgStatus_Name(static_cast<CIMMsgStatus>(enum_t_value));
}
bool CIMMsgStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMMsgStatus* value);
enum CIMMsgNotificationType : int {
  kCIM_MSG_NOTIFICATION_UNKNOWN = 0,
  kCIM_MSG_NOTIFICATION_GROUP_CREATE = 1,
  kCIM_MSG_NOTIFICATION_GROUP_BE_INVITE = 2,
  kCIM_MSG_NOTIFICATION_GROUP_KICK = 3,
  kCIM_MSG_NOTIFICATION_GROUP_LEAVE = 4,
  kCIM_MSG_NOTIFICATION_GROUP_UPDATE = 5,
  kCIM_MSG_NOTIFICATION_GROUP_DISMISS = 6,
  CIMMsgNotificationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMMsgNotificationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMMsgNotificationType_IsValid(int value);
constexpr CIMMsgNotificationType CIMMsgNotificationType_MIN = kCIM_MSG_NOTIFICATION_UNKNOWN;
constexpr CIMMsgNotificationType CIMMsgNotificationType_MAX = kCIM_MSG_NOTIFICATION_GROUP_DISMISS;
constexpr int CIMMsgNotificationType_ARRAYSIZE = CIMMsgNotificationType_MAX + 1;

const std::string& CIMMsgNotificationType_Name(CIMMsgNotificationType value);
template<typename T>
inline const std::string& CIMMsgNotificationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMMsgNotificationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMMsgNotificationType_Name.");
  return CIMMsgNotificationType_Name(static_cast<CIMMsgNotificationType>(enum_t_value));
}
bool CIMMsgNotificationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMMsgNotificationType* value);
enum CIMSessionStatusType : int {
  kCIM_SESSION_STATUS_UNKNOWN = 0,
  kCIM_SESSION_STATUS_OK = 1,
  kCIM_SESSION_STATUS_DELETE = 2,
  CIMSessionStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMSessionStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMSessionStatusType_IsValid(int value);
constexpr CIMSessionStatusType CIMSessionStatusType_MIN = kCIM_SESSION_STATUS_UNKNOWN;
constexpr CIMSessionStatusType CIMSessionStatusType_MAX = kCIM_SESSION_STATUS_DELETE;
constexpr int CIMSessionStatusType_ARRAYSIZE = CIMSessionStatusType_MAX + 1;

const std::string& CIMSessionStatusType_Name(CIMSessionStatusType value);
template<typename T>
inline const std::string& CIMSessionStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMSessionStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMSessionStatusType_Name.");
  return CIMSessionStatusType_Name(static_cast<CIMSessionStatusType>(enum_t_value));
}
bool CIMSessionStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMSessionStatusType* value);
enum CIMMsgFeature : int {
  kCIM_MSG_FEATURE_DEFAULT = 0,
  kCIM_MSG_FEATURE_ROAM_MSG = 2,
  CIMMsgFeature_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMMsgFeature_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMMsgFeature_IsValid(int value);
constexpr CIMMsgFeature CIMMsgFeature_MIN = kCIM_MSG_FEATURE_DEFAULT;
constexpr CIMMsgFeature CIMMsgFeature_MAX = kCIM_MSG_FEATURE_ROAM_MSG;
constexpr int CIMMsgFeature_ARRAYSIZE = CIMMsgFeature_MAX + 1;

const std::string& CIMMsgFeature_Name(CIMMsgFeature value);
template<typename T>
inline const std::string& CIMMsgFeature_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMMsgFeature>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMMsgFeature_Name.");
  return CIMMsgFeature_Name(static_cast<CIMMsgFeature>(enum_t_value));
}
bool CIMMsgFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMMsgFeature* value);
enum CIMVoipInviteType : int {
  kCIM_VOIP_INVITE_TYPE_UNKNOWN = 0,
  kCIM_VOIP_INVITE_TYPE_VOICE_CALL = 1,
  kCIM_VOIP_INVITE_TYPE_VIDEO_CALL = 2,
  CIMVoipInviteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMVoipInviteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMVoipInviteType_IsValid(int value);
constexpr CIMVoipInviteType CIMVoipInviteType_MIN = kCIM_VOIP_INVITE_TYPE_UNKNOWN;
constexpr CIMVoipInviteType CIMVoipInviteType_MAX = kCIM_VOIP_INVITE_TYPE_VIDEO_CALL;
constexpr int CIMVoipInviteType_ARRAYSIZE = CIMVoipInviteType_MAX + 1;

const std::string& CIMVoipInviteType_Name(CIMVoipInviteType value);
template<typename T>
inline const std::string& CIMVoipInviteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMVoipInviteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMVoipInviteType_Name.");
  return CIMVoipInviteType_Name(static_cast<CIMVoipInviteType>(enum_t_value));
}
bool CIMVoipInviteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMVoipInviteType* value);
enum CIMInviteRspCode : int {
  kCIM_VOIP_INVITE_CODE_UNKNOWN = 0,
  kCIM_VOIP_INVITE_CODE_TRYING = 100,
  kCIM_VOIP_INVITE_CODE_RINGING = 180,
  KCIM_VOIP_INVITE_CODE_OK = 200,
  CIMInviteRspCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMInviteRspCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMInviteRspCode_IsValid(int value);
constexpr CIMInviteRspCode CIMInviteRspCode_MIN = kCIM_VOIP_INVITE_CODE_UNKNOWN;
constexpr CIMInviteRspCode CIMInviteRspCode_MAX = KCIM_VOIP_INVITE_CODE_OK;
constexpr int CIMInviteRspCode_ARRAYSIZE = CIMInviteRspCode_MAX + 1;

const std::string& CIMInviteRspCode_Name(CIMInviteRspCode value);
template<typename T>
inline const std::string& CIMInviteRspCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMInviteRspCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMInviteRspCode_Name.");
  return CIMInviteRspCode_Name(static_cast<CIMInviteRspCode>(enum_t_value));
}
bool CIMInviteRspCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMInviteRspCode* value);
enum CIMVoipByeReason : int {
  kCIM_VOIP_BYE_REASON_UNKNOWN = 0,
  kCIM_VOIP_BYE_REASON_CANCEL = 1,
  kCIM_VOIP_BYE_REASON_REJECT = 2,
  kCIM_VOIP_BYE_REASON_END = 3,
  kCIM_VOIP_BYE_REASON_BUSY = 4,
  kCIM_VOIP_BYE_REASON_ONLINE_CLIENT_REJECT = 5,
  CIMVoipByeReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMVoipByeReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMVoipByeReason_IsValid(int value);
constexpr CIMVoipByeReason CIMVoipByeReason_MIN = kCIM_VOIP_BYE_REASON_UNKNOWN;
constexpr CIMVoipByeReason CIMVoipByeReason_MAX = kCIM_VOIP_BYE_REASON_ONLINE_CLIENT_REJECT;
constexpr int CIMVoipByeReason_ARRAYSIZE = CIMVoipByeReason_MAX + 1;

const std::string& CIMVoipByeReason_Name(CIMVoipByeReason value);
template<typename T>
inline const std::string& CIMVoipByeReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMVoipByeReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMVoipByeReason_Name.");
  return CIMVoipByeReason_Name(static_cast<CIMVoipByeReason>(enum_t_value));
}
bool CIMVoipByeReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMVoipByeReason* value);
enum CIMResCode : int {
  kCIM_RES_CODE_UNKNOWN = 0,
  kCIM_RES_CODE_OK = 1,
  CIMResCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CIMResCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CIMResCode_IsValid(int value);
constexpr CIMResCode CIMResCode_MIN = kCIM_RES_CODE_UNKNOWN;
constexpr CIMResCode CIMResCode_MAX = kCIM_RES_CODE_OK;
constexpr int CIMResCode_ARRAYSIZE = CIMResCode_MAX + 1;

const std::string& CIMResCode_Name(CIMResCode value);
template<typename T>
inline const std::string& CIMResCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CIMResCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CIMResCode_Name.");
  return CIMResCode_Name(static_cast<CIMResCode>(enum_t_value));
}
bool CIMResCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CIMResCode* value);
// ===================================================================

class CIMUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CIM.Def.CIMUserInfo) */ {
 public:
  inline CIMUserInfo() : CIMUserInfo(nullptr) {}
  ~CIMUserInfo() override;
  explicit PROTOBUF_CONSTEXPR CIMUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CIMUserInfo(const CIMUserInfo& from);
  CIMUserInfo(CIMUserInfo&& from) noexcept
    : CIMUserInfo() {
    *this = ::std::move(from);
  }

  inline CIMUserInfo& operator=(const CIMUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CIMUserInfo& operator=(CIMUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CIMUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CIMUserInfo* internal_default_instance() {
    return reinterpret_cast<const CIMUserInfo*>(
               &_CIMUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CIMUserInfo& a, CIMUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CIMUserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CIMUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CIMUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CIMUserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CIMUserInfo& from);
  void MergeFrom(const CIMUserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CIMUserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CIM.Def.CIMUserInfo";
  }
  protected:
  explicit CIMUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickNameFieldNumber = 2,
    kNickNameSpellFieldNumber = 3,
    kPhoneFieldNumber = 9,
    kAvatarUrlFieldNumber = 10,
    kAttachInfoFieldNumber = 11,
    kUserIdFieldNumber = 1,
  };
  // string nick_name = 2;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // string nick_name_spell = 3;
  void clear_nick_name_spell();
  const std::string& nick_name_spell() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name_spell(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name_spell();
  PROTOBUF_NODISCARD std::string* release_nick_name_spell();
  void set_allocated_nick_name_spell(std::string* nick_name_spell);
  private:
  const std::string& _internal_nick_name_spell() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name_spell(const std::string& value);
  std::string* _internal_mutable_nick_name_spell();
  public:

  // string phone = 9;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // string avatar_url = 10;
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // string attach_info = 11;
  void clear_attach_info();
  const std::string& attach_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_info();
  PROTOBUF_NODISCARD std::string* release_attach_info();
  void set_allocated_attach_info(std::string* attach_info);
  private:
  const std::string& _internal_attach_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_info(const std::string& value);
  std::string* _internal_mutable_attach_info();
  public:

  // uint64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CIM.Def.CIMUserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_spell_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_info_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CIM_2eDef_2eproto;
};
// -------------------------------------------------------------------

class CIMContactSessionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CIM.Def.CIMContactSessionInfo) */ {
 public:
  inline CIMContactSessionInfo() : CIMContactSessionInfo(nullptr) {}
  ~CIMContactSessionInfo() override;
  explicit PROTOBUF_CONSTEXPR CIMContactSessionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CIMContactSessionInfo(const CIMContactSessionInfo& from);
  CIMContactSessionInfo(CIMContactSessionInfo&& from) noexcept
    : CIMContactSessionInfo() {
    *this = ::std::move(from);
  }

  inline CIMContactSessionInfo& operator=(const CIMContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CIMContactSessionInfo& operator=(CIMContactSessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CIMContactSessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CIMContactSessionInfo* internal_default_instance() {
    return reinterpret_cast<const CIMContactSessionInfo*>(
               &_CIMContactSessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CIMContactSessionInfo& a, CIMContactSessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CIMContactSessionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CIMContactSessionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CIMContactSessionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CIMContactSessionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CIMContactSessionInfo& from);
  void MergeFrom(const CIMContactSessionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CIMContactSessionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CIM.Def.CIMContactSessionInfo";
  }
  protected:
  explicit CIMContactSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgIdFieldNumber = 6,
    kMsgDataFieldNumber = 9,
    kMsgAttachFieldNumber = 13,
    kExtendDataFieldNumber = 14,
    kSessionIdFieldNumber = 1,
    kSessionTypeFieldNumber = 2,
    kSessionStatusFieldNumber = 3,
    kUnreadCntFieldNumber = 4,
    kUpdatedTimeFieldNumber = 5,
    kServerMsgIdFieldNumber = 7,
    kMsgTimeStampFieldNumber = 8,
    kMsgTypeFieldNumber = 10,
    kMsgFromUserIdFieldNumber = 11,
    kMsgStatusFieldNumber = 12,
    kIsRobotSessionFieldNumber = 15,
  };
  // string msg_id = 6;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // bytes msg_data = 9;
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // string msg_attach = 13;
  void clear_msg_attach();
  const std::string& msg_attach() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_attach(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_attach();
  PROTOBUF_NODISCARD std::string* release_msg_attach();
  void set_allocated_msg_attach(std::string* msg_attach);
  private:
  const std::string& _internal_msg_attach() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_attach(const std::string& value);
  std::string* _internal_mutable_msg_attach();
  public:

  // string extend_data = 14;
  void clear_extend_data();
  const std::string& extend_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extend_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extend_data();
  PROTOBUF_NODISCARD std::string* release_extend_data();
  void set_allocated_extend_data(std::string* extend_data);
  private:
  const std::string& _internal_extend_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extend_data(const std::string& value);
  std::string* _internal_mutable_extend_data();
  public:

  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // .CIM.Def.CIMSessionType session_type = 2;
  void clear_session_type();
  ::CIM::Def::CIMSessionType session_type() const;
  void set_session_type(::CIM::Def::CIMSessionType value);
  private:
  ::CIM::Def::CIMSessionType _internal_session_type() const;
  void _internal_set_session_type(::CIM::Def::CIMSessionType value);
  public:

  // .CIM.Def.CIMSessionStatusType session_status = 3;
  void clear_session_status();
  ::CIM::Def::CIMSessionStatusType session_status() const;
  void set_session_status(::CIM::Def::CIMSessionStatusType value);
  private:
  ::CIM::Def::CIMSessionStatusType _internal_session_status() const;
  void _internal_set_session_status(::CIM::Def::CIMSessionStatusType value);
  public:

  // uint32 unread_cnt = 4;
  void clear_unread_cnt();
  uint32_t unread_cnt() const;
  void set_unread_cnt(uint32_t value);
  private:
  uint32_t _internal_unread_cnt() const;
  void _internal_set_unread_cnt(uint32_t value);
  public:

  // uint32 updated_time = 5;
  void clear_updated_time();
  uint32_t updated_time() const;
  void set_updated_time(uint32_t value);
  private:
  uint32_t _internal_updated_time() const;
  void _internal_set_updated_time(uint32_t value);
  public:

  // uint64 server_msg_id = 7;
  void clear_server_msg_id();
  uint64_t server_msg_id() const;
  void set_server_msg_id(uint64_t value);
  private:
  uint64_t _internal_server_msg_id() const;
  void _internal_set_server_msg_id(uint64_t value);
  public:

  // uint32 msg_time_stamp = 8;
  void clear_msg_time_stamp();
  uint32_t msg_time_stamp() const;
  void set_msg_time_stamp(uint32_t value);
  private:
  uint32_t _internal_msg_time_stamp() const;
  void _internal_set_msg_time_stamp(uint32_t value);
  public:

  // .CIM.Def.CIMMsgType msg_type = 10;
  void clear_msg_type();
  ::CIM::Def::CIMMsgType msg_type() const;
  void set_msg_type(::CIM::Def::CIMMsgType value);
  private:
  ::CIM::Def::CIMMsgType _internal_msg_type() const;
  void _internal_set_msg_type(::CIM::Def::CIMMsgType value);
  public:

  // uint64 msg_from_user_id = 11;
  void clear_msg_from_user_id();
  uint64_t msg_from_user_id() const;
  void set_msg_from_user_id(uint64_t value);
  private:
  uint64_t _internal_msg_from_user_id() const;
  void _internal_set_msg_from_user_id(uint64_t value);
  public:

  // .CIM.Def.CIMMsgStatus msg_status = 12;
  void clear_msg_status();
  ::CIM::Def::CIMMsgStatus msg_status() const;
  void set_msg_status(::CIM::Def::CIMMsgStatus value);
  private:
  ::CIM::Def::CIMMsgStatus _internal_msg_status() const;
  void _internal_set_msg_status(::CIM::Def::CIMMsgStatus value);
  public:

  // bool is_robot_session = 15;
  void clear_is_robot_session();
  bool is_robot_session() const;
  void set_is_robot_session(bool value);
  private:
  bool _internal_is_robot_session() const;
  void _internal_set_is_robot_session(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CIM.Def.CIMContactSessionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_attach_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extend_data_;
  uint64_t session_id_;
  int session_type_;
  int session_status_;
  uint32_t unread_cnt_;
  uint32_t updated_time_;
  uint64_t server_msg_id_;
  uint32_t msg_time_stamp_;
  int msg_type_;
  uint64_t msg_from_user_id_;
  int msg_status_;
  bool is_robot_session_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CIM_2eDef_2eproto;
};
// -------------------------------------------------------------------

class CIMMsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CIM.Def.CIMMsgInfo) */ {
 public:
  inline CIMMsgInfo() : CIMMsgInfo(nullptr) {}
  ~CIMMsgInfo() override;
  explicit PROTOBUF_CONSTEXPR CIMMsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CIMMsgInfo(const CIMMsgInfo& from);
  CIMMsgInfo(CIMMsgInfo&& from) noexcept
    : CIMMsgInfo() {
    *this = ::std::move(from);
  }

  inline CIMMsgInfo& operator=(const CIMMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CIMMsgInfo& operator=(CIMMsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CIMMsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CIMMsgInfo* internal_default_instance() {
    return reinterpret_cast<const CIMMsgInfo*>(
               &_CIMMsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CIMMsgInfo& a, CIMMsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CIMMsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CIMMsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CIMMsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CIMMsgInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CIMMsgInfo& from);
  void MergeFrom(const CIMMsgInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CIMMsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CIM.Def.CIMMsgInfo";
  }
  protected:
  explicit CIMMsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientMsgIdFieldNumber = 1,
    kMsgDataFieldNumber = 11,
    kAttachFieldNumber = 12,
    kServerMsgIdFieldNumber = 2,
    kMsgResCodeFieldNumber = 3,
    kMsgFeatureFieldNumber = 4,
    kFromUserIdFieldNumber = 6,
    kSessionTypeFieldNumber = 5,
    kCreateTimeFieldNumber = 8,
    kToSessionIdFieldNumber = 7,
    kMsgTypeFieldNumber = 9,
    kMsgStatusFieldNumber = 10,
    kSenderClientTypeFieldNumber = 13,
  };
  // string client_msg_id = 1;
  void clear_client_msg_id();
  const std::string& client_msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_msg_id();
  PROTOBUF_NODISCARD std::string* release_client_msg_id();
  void set_allocated_client_msg_id(std::string* client_msg_id);
  private:
  const std::string& _internal_client_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_msg_id(const std::string& value);
  std::string* _internal_mutable_client_msg_id();
  public:

  // bytes msg_data = 11;
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // string attach = 12;
  void clear_attach();
  const std::string& attach() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach();
  PROTOBUF_NODISCARD std::string* release_attach();
  void set_allocated_attach(std::string* attach);
  private:
  const std::string& _internal_attach() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach(const std::string& value);
  std::string* _internal_mutable_attach();
  public:

  // uint64 server_msg_id = 2;
  void clear_server_msg_id();
  uint64_t server_msg_id() const;
  void set_server_msg_id(uint64_t value);
  private:
  uint64_t _internal_server_msg_id() const;
  void _internal_set_server_msg_id(uint64_t value);
  public:

  // .CIM.Def.CIMResCode msg_res_code = 3;
  void clear_msg_res_code();
  ::CIM::Def::CIMResCode msg_res_code() const;
  void set_msg_res_code(::CIM::Def::CIMResCode value);
  private:
  ::CIM::Def::CIMResCode _internal_msg_res_code() const;
  void _internal_set_msg_res_code(::CIM::Def::CIMResCode value);
  public:

  // .CIM.Def.CIMMsgFeature msg_feature = 4;
  void clear_msg_feature();
  ::CIM::Def::CIMMsgFeature msg_feature() const;
  void set_msg_feature(::CIM::Def::CIMMsgFeature value);
  private:
  ::CIM::Def::CIMMsgFeature _internal_msg_feature() const;
  void _internal_set_msg_feature(::CIM::Def::CIMMsgFeature value);
  public:

  // uint64 from_user_id = 6;
  void clear_from_user_id();
  uint64_t from_user_id() const;
  void set_from_user_id(uint64_t value);
  private:
  uint64_t _internal_from_user_id() const;
  void _internal_set_from_user_id(uint64_t value);
  public:

  // .CIM.Def.CIMSessionType session_type = 5;
  void clear_session_type();
  ::CIM::Def::CIMSessionType session_type() const;
  void set_session_type(::CIM::Def::CIMSessionType value);
  private:
  ::CIM::Def::CIMSessionType _internal_session_type() const;
  void _internal_set_session_type(::CIM::Def::CIMSessionType value);
  public:

  // uint32 create_time = 8;
  void clear_create_time();
  uint32_t create_time() const;
  void set_create_time(uint32_t value);
  private:
  uint32_t _internal_create_time() const;
  void _internal_set_create_time(uint32_t value);
  public:

  // uint64 to_session_id = 7;
  void clear_to_session_id();
  uint64_t to_session_id() const;
  void set_to_session_id(uint64_t value);
  private:
  uint64_t _internal_to_session_id() const;
  void _internal_set_to_session_id(uint64_t value);
  public:

  // .CIM.Def.CIMMsgType msg_type = 9;
  void clear_msg_type();
  ::CIM::Def::CIMMsgType msg_type() const;
  void set_msg_type(::CIM::Def::CIMMsgType value);
  private:
  ::CIM::Def::CIMMsgType _internal_msg_type() const;
  void _internal_set_msg_type(::CIM::Def::CIMMsgType value);
  public:

  // .CIM.Def.CIMMsgStatus msg_status = 10;
  void clear_msg_status();
  ::CIM::Def::CIMMsgStatus msg_status() const;
  void set_msg_status(::CIM::Def::CIMMsgStatus value);
  private:
  ::CIM::Def::CIMMsgStatus _internal_msg_status() const;
  void _internal_set_msg_status(::CIM::Def::CIMMsgStatus value);
  public:

  // .CIM.Def.CIMClientType sender_client_type = 13;
  void clear_sender_client_type();
  ::CIM::Def::CIMClientType sender_client_type() const;
  void set_sender_client_type(::CIM::Def::CIMClientType value);
  private:
  ::CIM::Def::CIMClientType _internal_sender_client_type() const;
  void _internal_set_sender_client_type(::CIM::Def::CIMClientType value);
  public:

  // @@protoc_insertion_point(class_scope:CIM.Def.CIMMsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_msg_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_;
  uint64_t server_msg_id_;
  int msg_res_code_;
  int msg_feature_;
  uint64_t from_user_id_;
  int session_type_;
  uint32_t create_time_;
  uint64_t to_session_id_;
  int msg_type_;
  int msg_status_;
  int sender_client_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CIM_2eDef_2eproto;
};
// -------------------------------------------------------------------

class CIMChannelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:CIM.Def.CIMChannelInfo) */ {
 public:
  inline CIMChannelInfo() : CIMChannelInfo(nullptr) {}
  ~CIMChannelInfo() override;
  explicit PROTOBUF_CONSTEXPR CIMChannelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CIMChannelInfo(const CIMChannelInfo& from);
  CIMChannelInfo(CIMChannelInfo&& from) noexcept
    : CIMChannelInfo() {
    *this = ::std::move(from);
  }

  inline CIMChannelInfo& operator=(const CIMChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CIMChannelInfo& operator=(CIMChannelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CIMChannelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CIMChannelInfo* internal_default_instance() {
    return reinterpret_cast<const CIMChannelInfo*>(
               &_CIMChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CIMChannelInfo& a, CIMChannelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CIMChannelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CIMChannelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CIMChannelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CIMChannelInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CIMChannelInfo& from);
  void MergeFrom(const CIMChannelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CIMChannelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CIM.Def.CIMChannelInfo";
  }
  protected:
  explicit CIMChannelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelNameFieldNumber = 1,
    kChannelTokenFieldNumber = 2,
    kCreatorIdFieldNumber = 3,
  };
  // string channel_name = 1;
  void clear_channel_name();
  const std::string& channel_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_name();
  PROTOBUF_NODISCARD std::string* release_channel_name();
  void set_allocated_channel_name(std::string* channel_name);
  private:
  const std::string& _internal_channel_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_name(const std::string& value);
  std::string* _internal_mutable_channel_name();
  public:

  // string channel_token = 2;
  void clear_channel_token();
  const std::string& channel_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_token();
  PROTOBUF_NODISCARD std::string* release_channel_token();
  void set_allocated_channel_token(std::string* channel_token);
  private:
  const std::string& _internal_channel_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_token(const std::string& value);
  std::string* _internal_mutable_channel_token();
  public:

  // uint64 creator_id = 3;
  void clear_creator_id();
  uint64_t creator_id() const;
  void set_creator_id(uint64_t value);
  private:
  uint64_t _internal_creator_id() const;
  void _internal_set_creator_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CIM.Def.CIMChannelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_token_;
  uint64_t creator_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CIM_2eDef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CIMUserInfo

// uint64 user_id = 1;
inline void CIMUserInfo::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t CIMUserInfo::_internal_user_id() const {
  return user_id_;
}
inline uint64_t CIMUserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.user_id)
  return _internal_user_id();
}
inline void CIMUserInfo::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void CIMUserInfo::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.user_id)
}

// string nick_name = 2;
inline void CIMUserInfo::clear_nick_name() {
  nick_name_.ClearToEmpty();
}
inline const std::string& CIMUserInfo::nick_name() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMUserInfo::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.nick_name)
}
inline std::string* CIMUserInfo::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMUserInfo.nick_name)
  return _s;
}
inline const std::string& CIMUserInfo::_internal_nick_name() const {
  return nick_name_.Get();
}
inline void CIMUserInfo::_internal_set_nick_name(const std::string& value) {
  
  nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMUserInfo::_internal_mutable_nick_name() {
  
  return nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMUserInfo::release_nick_name() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMUserInfo.nick_name)
  return nick_name_.Release();
}
inline void CIMUserInfo::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nick_name_.IsDefault()) {
    nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMUserInfo.nick_name)
}

// string nick_name_spell = 3;
inline void CIMUserInfo::clear_nick_name_spell() {
  nick_name_spell_.ClearToEmpty();
}
inline const std::string& CIMUserInfo::nick_name_spell() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.nick_name_spell)
  return _internal_nick_name_spell();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMUserInfo::set_nick_name_spell(ArgT0&& arg0, ArgT... args) {
 
 nick_name_spell_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.nick_name_spell)
}
inline std::string* CIMUserInfo::mutable_nick_name_spell() {
  std::string* _s = _internal_mutable_nick_name_spell();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMUserInfo.nick_name_spell)
  return _s;
}
inline const std::string& CIMUserInfo::_internal_nick_name_spell() const {
  return nick_name_spell_.Get();
}
inline void CIMUserInfo::_internal_set_nick_name_spell(const std::string& value) {
  
  nick_name_spell_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMUserInfo::_internal_mutable_nick_name_spell() {
  
  return nick_name_spell_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMUserInfo::release_nick_name_spell() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMUserInfo.nick_name_spell)
  return nick_name_spell_.Release();
}
inline void CIMUserInfo::set_allocated_nick_name_spell(std::string* nick_name_spell) {
  if (nick_name_spell != nullptr) {
    
  } else {
    
  }
  nick_name_spell_.SetAllocated(nick_name_spell, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nick_name_spell_.IsDefault()) {
    nick_name_spell_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMUserInfo.nick_name_spell)
}

// string phone = 9;
inline void CIMUserInfo::clear_phone() {
  phone_.ClearToEmpty();
}
inline const std::string& CIMUserInfo::phone() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMUserInfo::set_phone(ArgT0&& arg0, ArgT... args) {
 
 phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.phone)
}
inline std::string* CIMUserInfo::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMUserInfo.phone)
  return _s;
}
inline const std::string& CIMUserInfo::_internal_phone() const {
  return phone_.Get();
}
inline void CIMUserInfo::_internal_set_phone(const std::string& value) {
  
  phone_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMUserInfo::_internal_mutable_phone() {
  
  return phone_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMUserInfo::release_phone() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMUserInfo.phone)
  return phone_.Release();
}
inline void CIMUserInfo::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_.IsDefault()) {
    phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMUserInfo.phone)
}

// string avatar_url = 10;
inline void CIMUserInfo::clear_avatar_url() {
  avatar_url_.ClearToEmpty();
}
inline const std::string& CIMUserInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMUserInfo::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 
 avatar_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.avatar_url)
}
inline std::string* CIMUserInfo::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMUserInfo.avatar_url)
  return _s;
}
inline const std::string& CIMUserInfo::_internal_avatar_url() const {
  return avatar_url_.Get();
}
inline void CIMUserInfo::_internal_set_avatar_url(const std::string& value) {
  
  avatar_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMUserInfo::_internal_mutable_avatar_url() {
  
  return avatar_url_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMUserInfo::release_avatar_url() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMUserInfo.avatar_url)
  return avatar_url_.Release();
}
inline void CIMUserInfo::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    
  } else {
    
  }
  avatar_url_.SetAllocated(avatar_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_url_.IsDefault()) {
    avatar_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMUserInfo.avatar_url)
}

// string attach_info = 11;
inline void CIMUserInfo::clear_attach_info() {
  attach_info_.ClearToEmpty();
}
inline const std::string& CIMUserInfo::attach_info() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMUserInfo.attach_info)
  return _internal_attach_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMUserInfo::set_attach_info(ArgT0&& arg0, ArgT... args) {
 
 attach_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMUserInfo.attach_info)
}
inline std::string* CIMUserInfo::mutable_attach_info() {
  std::string* _s = _internal_mutable_attach_info();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMUserInfo.attach_info)
  return _s;
}
inline const std::string& CIMUserInfo::_internal_attach_info() const {
  return attach_info_.Get();
}
inline void CIMUserInfo::_internal_set_attach_info(const std::string& value) {
  
  attach_info_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMUserInfo::_internal_mutable_attach_info() {
  
  return attach_info_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMUserInfo::release_attach_info() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMUserInfo.attach_info)
  return attach_info_.Release();
}
inline void CIMUserInfo::set_allocated_attach_info(std::string* attach_info) {
  if (attach_info != nullptr) {
    
  } else {
    
  }
  attach_info_.SetAllocated(attach_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attach_info_.IsDefault()) {
    attach_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMUserInfo.attach_info)
}

// -------------------------------------------------------------------

// CIMContactSessionInfo

// uint64 session_id = 1;
inline void CIMContactSessionInfo::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t CIMContactSessionInfo::_internal_session_id() const {
  return session_id_;
}
inline uint64_t CIMContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.session_id)
  return _internal_session_id();
}
inline void CIMContactSessionInfo::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void CIMContactSessionInfo::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.session_id)
}

// .CIM.Def.CIMSessionType session_type = 2;
inline void CIMContactSessionInfo::clear_session_type() {
  session_type_ = 0;
}
inline ::CIM::Def::CIMSessionType CIMContactSessionInfo::_internal_session_type() const {
  return static_cast< ::CIM::Def::CIMSessionType >(session_type_);
}
inline ::CIM::Def::CIMSessionType CIMContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.session_type)
  return _internal_session_type();
}
inline void CIMContactSessionInfo::_internal_set_session_type(::CIM::Def::CIMSessionType value) {
  
  session_type_ = value;
}
inline void CIMContactSessionInfo::set_session_type(::CIM::Def::CIMSessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.session_type)
}

// .CIM.Def.CIMSessionStatusType session_status = 3;
inline void CIMContactSessionInfo::clear_session_status() {
  session_status_ = 0;
}
inline ::CIM::Def::CIMSessionStatusType CIMContactSessionInfo::_internal_session_status() const {
  return static_cast< ::CIM::Def::CIMSessionStatusType >(session_status_);
}
inline ::CIM::Def::CIMSessionStatusType CIMContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.session_status)
  return _internal_session_status();
}
inline void CIMContactSessionInfo::_internal_set_session_status(::CIM::Def::CIMSessionStatusType value) {
  
  session_status_ = value;
}
inline void CIMContactSessionInfo::set_session_status(::CIM::Def::CIMSessionStatusType value) {
  _internal_set_session_status(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.session_status)
}

// uint32 unread_cnt = 4;
inline void CIMContactSessionInfo::clear_unread_cnt() {
  unread_cnt_ = 0u;
}
inline uint32_t CIMContactSessionInfo::_internal_unread_cnt() const {
  return unread_cnt_;
}
inline uint32_t CIMContactSessionInfo::unread_cnt() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.unread_cnt)
  return _internal_unread_cnt();
}
inline void CIMContactSessionInfo::_internal_set_unread_cnt(uint32_t value) {
  
  unread_cnt_ = value;
}
inline void CIMContactSessionInfo::set_unread_cnt(uint32_t value) {
  _internal_set_unread_cnt(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.unread_cnt)
}

// uint32 updated_time = 5;
inline void CIMContactSessionInfo::clear_updated_time() {
  updated_time_ = 0u;
}
inline uint32_t CIMContactSessionInfo::_internal_updated_time() const {
  return updated_time_;
}
inline uint32_t CIMContactSessionInfo::updated_time() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.updated_time)
  return _internal_updated_time();
}
inline void CIMContactSessionInfo::_internal_set_updated_time(uint32_t value) {
  
  updated_time_ = value;
}
inline void CIMContactSessionInfo::set_updated_time(uint32_t value) {
  _internal_set_updated_time(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.updated_time)
}

// string msg_id = 6;
inline void CIMContactSessionInfo::clear_msg_id() {
  msg_id_.ClearToEmpty();
}
inline const std::string& CIMContactSessionInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMContactSessionInfo::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_id)
}
inline std::string* CIMContactSessionInfo::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMContactSessionInfo.msg_id)
  return _s;
}
inline const std::string& CIMContactSessionInfo::_internal_msg_id() const {
  return msg_id_.Get();
}
inline void CIMContactSessionInfo::_internal_set_msg_id(const std::string& value) {
  
  msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::_internal_mutable_msg_id() {
  
  return msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::release_msg_id() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMContactSessionInfo.msg_id)
  return msg_id_.Release();
}
inline void CIMContactSessionInfo::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_id_.IsDefault()) {
    msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMContactSessionInfo.msg_id)
}

// uint64 server_msg_id = 7;
inline void CIMContactSessionInfo::clear_server_msg_id() {
  server_msg_id_ = uint64_t{0u};
}
inline uint64_t CIMContactSessionInfo::_internal_server_msg_id() const {
  return server_msg_id_;
}
inline uint64_t CIMContactSessionInfo::server_msg_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.server_msg_id)
  return _internal_server_msg_id();
}
inline void CIMContactSessionInfo::_internal_set_server_msg_id(uint64_t value) {
  
  server_msg_id_ = value;
}
inline void CIMContactSessionInfo::set_server_msg_id(uint64_t value) {
  _internal_set_server_msg_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.server_msg_id)
}

// uint32 msg_time_stamp = 8;
inline void CIMContactSessionInfo::clear_msg_time_stamp() {
  msg_time_stamp_ = 0u;
}
inline uint32_t CIMContactSessionInfo::_internal_msg_time_stamp() const {
  return msg_time_stamp_;
}
inline uint32_t CIMContactSessionInfo::msg_time_stamp() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_time_stamp)
  return _internal_msg_time_stamp();
}
inline void CIMContactSessionInfo::_internal_set_msg_time_stamp(uint32_t value) {
  
  msg_time_stamp_ = value;
}
inline void CIMContactSessionInfo::set_msg_time_stamp(uint32_t value) {
  _internal_set_msg_time_stamp(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_time_stamp)
}

// bytes msg_data = 9;
inline void CIMContactSessionInfo::clear_msg_data() {
  msg_data_.ClearToEmpty();
}
inline const std::string& CIMContactSessionInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMContactSessionInfo::set_msg_data(ArgT0&& arg0, ArgT... args) {
 
 msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_data)
}
inline std::string* CIMContactSessionInfo::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMContactSessionInfo.msg_data)
  return _s;
}
inline const std::string& CIMContactSessionInfo::_internal_msg_data() const {
  return msg_data_.Get();
}
inline void CIMContactSessionInfo::_internal_set_msg_data(const std::string& value) {
  
  msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::_internal_mutable_msg_data() {
  
  return msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMContactSessionInfo.msg_data)
  return msg_data_.Release();
}
inline void CIMContactSessionInfo::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    
  } else {
    
  }
  msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_data_.IsDefault()) {
    msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMContactSessionInfo.msg_data)
}

// .CIM.Def.CIMMsgType msg_type = 10;
inline void CIMContactSessionInfo::clear_msg_type() {
  msg_type_ = 0;
}
inline ::CIM::Def::CIMMsgType CIMContactSessionInfo::_internal_msg_type() const {
  return static_cast< ::CIM::Def::CIMMsgType >(msg_type_);
}
inline ::CIM::Def::CIMMsgType CIMContactSessionInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_type)
  return _internal_msg_type();
}
inline void CIMContactSessionInfo::_internal_set_msg_type(::CIM::Def::CIMMsgType value) {
  
  msg_type_ = value;
}
inline void CIMContactSessionInfo::set_msg_type(::CIM::Def::CIMMsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_type)
}

// uint64 msg_from_user_id = 11;
inline void CIMContactSessionInfo::clear_msg_from_user_id() {
  msg_from_user_id_ = uint64_t{0u};
}
inline uint64_t CIMContactSessionInfo::_internal_msg_from_user_id() const {
  return msg_from_user_id_;
}
inline uint64_t CIMContactSessionInfo::msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_from_user_id)
  return _internal_msg_from_user_id();
}
inline void CIMContactSessionInfo::_internal_set_msg_from_user_id(uint64_t value) {
  
  msg_from_user_id_ = value;
}
inline void CIMContactSessionInfo::set_msg_from_user_id(uint64_t value) {
  _internal_set_msg_from_user_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_from_user_id)
}

// .CIM.Def.CIMMsgStatus msg_status = 12;
inline void CIMContactSessionInfo::clear_msg_status() {
  msg_status_ = 0;
}
inline ::CIM::Def::CIMMsgStatus CIMContactSessionInfo::_internal_msg_status() const {
  return static_cast< ::CIM::Def::CIMMsgStatus >(msg_status_);
}
inline ::CIM::Def::CIMMsgStatus CIMContactSessionInfo::msg_status() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_status)
  return _internal_msg_status();
}
inline void CIMContactSessionInfo::_internal_set_msg_status(::CIM::Def::CIMMsgStatus value) {
  
  msg_status_ = value;
}
inline void CIMContactSessionInfo::set_msg_status(::CIM::Def::CIMMsgStatus value) {
  _internal_set_msg_status(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_status)
}

// string msg_attach = 13;
inline void CIMContactSessionInfo::clear_msg_attach() {
  msg_attach_.ClearToEmpty();
}
inline const std::string& CIMContactSessionInfo::msg_attach() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.msg_attach)
  return _internal_msg_attach();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMContactSessionInfo::set_msg_attach(ArgT0&& arg0, ArgT... args) {
 
 msg_attach_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.msg_attach)
}
inline std::string* CIMContactSessionInfo::mutable_msg_attach() {
  std::string* _s = _internal_mutable_msg_attach();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMContactSessionInfo.msg_attach)
  return _s;
}
inline const std::string& CIMContactSessionInfo::_internal_msg_attach() const {
  return msg_attach_.Get();
}
inline void CIMContactSessionInfo::_internal_set_msg_attach(const std::string& value) {
  
  msg_attach_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::_internal_mutable_msg_attach() {
  
  return msg_attach_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::release_msg_attach() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMContactSessionInfo.msg_attach)
  return msg_attach_.Release();
}
inline void CIMContactSessionInfo::set_allocated_msg_attach(std::string* msg_attach) {
  if (msg_attach != nullptr) {
    
  } else {
    
  }
  msg_attach_.SetAllocated(msg_attach, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_attach_.IsDefault()) {
    msg_attach_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMContactSessionInfo.msg_attach)
}

// string extend_data = 14;
inline void CIMContactSessionInfo::clear_extend_data() {
  extend_data_.ClearToEmpty();
}
inline const std::string& CIMContactSessionInfo::extend_data() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.extend_data)
  return _internal_extend_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMContactSessionInfo::set_extend_data(ArgT0&& arg0, ArgT... args) {
 
 extend_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.extend_data)
}
inline std::string* CIMContactSessionInfo::mutable_extend_data() {
  std::string* _s = _internal_mutable_extend_data();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMContactSessionInfo.extend_data)
  return _s;
}
inline const std::string& CIMContactSessionInfo::_internal_extend_data() const {
  return extend_data_.Get();
}
inline void CIMContactSessionInfo::_internal_set_extend_data(const std::string& value) {
  
  extend_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::_internal_mutable_extend_data() {
  
  return extend_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMContactSessionInfo::release_extend_data() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMContactSessionInfo.extend_data)
  return extend_data_.Release();
}
inline void CIMContactSessionInfo::set_allocated_extend_data(std::string* extend_data) {
  if (extend_data != nullptr) {
    
  } else {
    
  }
  extend_data_.SetAllocated(extend_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extend_data_.IsDefault()) {
    extend_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMContactSessionInfo.extend_data)
}

// bool is_robot_session = 15;
inline void CIMContactSessionInfo::clear_is_robot_session() {
  is_robot_session_ = false;
}
inline bool CIMContactSessionInfo::_internal_is_robot_session() const {
  return is_robot_session_;
}
inline bool CIMContactSessionInfo::is_robot_session() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMContactSessionInfo.is_robot_session)
  return _internal_is_robot_session();
}
inline void CIMContactSessionInfo::_internal_set_is_robot_session(bool value) {
  
  is_robot_session_ = value;
}
inline void CIMContactSessionInfo::set_is_robot_session(bool value) {
  _internal_set_is_robot_session(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMContactSessionInfo.is_robot_session)
}

// -------------------------------------------------------------------

// CIMMsgInfo

// string client_msg_id = 1;
inline void CIMMsgInfo::clear_client_msg_id() {
  client_msg_id_.ClearToEmpty();
}
inline const std::string& CIMMsgInfo::client_msg_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.client_msg_id)
  return _internal_client_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMMsgInfo::set_client_msg_id(ArgT0&& arg0, ArgT... args) {
 
 client_msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.client_msg_id)
}
inline std::string* CIMMsgInfo::mutable_client_msg_id() {
  std::string* _s = _internal_mutable_client_msg_id();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMMsgInfo.client_msg_id)
  return _s;
}
inline const std::string& CIMMsgInfo::_internal_client_msg_id() const {
  return client_msg_id_.Get();
}
inline void CIMMsgInfo::_internal_set_client_msg_id(const std::string& value) {
  
  client_msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::_internal_mutable_client_msg_id() {
  
  return client_msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::release_client_msg_id() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMMsgInfo.client_msg_id)
  return client_msg_id_.Release();
}
inline void CIMMsgInfo::set_allocated_client_msg_id(std::string* client_msg_id) {
  if (client_msg_id != nullptr) {
    
  } else {
    
  }
  client_msg_id_.SetAllocated(client_msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_msg_id_.IsDefault()) {
    client_msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMMsgInfo.client_msg_id)
}

// uint64 server_msg_id = 2;
inline void CIMMsgInfo::clear_server_msg_id() {
  server_msg_id_ = uint64_t{0u};
}
inline uint64_t CIMMsgInfo::_internal_server_msg_id() const {
  return server_msg_id_;
}
inline uint64_t CIMMsgInfo::server_msg_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.server_msg_id)
  return _internal_server_msg_id();
}
inline void CIMMsgInfo::_internal_set_server_msg_id(uint64_t value) {
  
  server_msg_id_ = value;
}
inline void CIMMsgInfo::set_server_msg_id(uint64_t value) {
  _internal_set_server_msg_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.server_msg_id)
}

// .CIM.Def.CIMResCode msg_res_code = 3;
inline void CIMMsgInfo::clear_msg_res_code() {
  msg_res_code_ = 0;
}
inline ::CIM::Def::CIMResCode CIMMsgInfo::_internal_msg_res_code() const {
  return static_cast< ::CIM::Def::CIMResCode >(msg_res_code_);
}
inline ::CIM::Def::CIMResCode CIMMsgInfo::msg_res_code() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.msg_res_code)
  return _internal_msg_res_code();
}
inline void CIMMsgInfo::_internal_set_msg_res_code(::CIM::Def::CIMResCode value) {
  
  msg_res_code_ = value;
}
inline void CIMMsgInfo::set_msg_res_code(::CIM::Def::CIMResCode value) {
  _internal_set_msg_res_code(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.msg_res_code)
}

// .CIM.Def.CIMMsgFeature msg_feature = 4;
inline void CIMMsgInfo::clear_msg_feature() {
  msg_feature_ = 0;
}
inline ::CIM::Def::CIMMsgFeature CIMMsgInfo::_internal_msg_feature() const {
  return static_cast< ::CIM::Def::CIMMsgFeature >(msg_feature_);
}
inline ::CIM::Def::CIMMsgFeature CIMMsgInfo::msg_feature() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.msg_feature)
  return _internal_msg_feature();
}
inline void CIMMsgInfo::_internal_set_msg_feature(::CIM::Def::CIMMsgFeature value) {
  
  msg_feature_ = value;
}
inline void CIMMsgInfo::set_msg_feature(::CIM::Def::CIMMsgFeature value) {
  _internal_set_msg_feature(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.msg_feature)
}

// .CIM.Def.CIMSessionType session_type = 5;
inline void CIMMsgInfo::clear_session_type() {
  session_type_ = 0;
}
inline ::CIM::Def::CIMSessionType CIMMsgInfo::_internal_session_type() const {
  return static_cast< ::CIM::Def::CIMSessionType >(session_type_);
}
inline ::CIM::Def::CIMSessionType CIMMsgInfo::session_type() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.session_type)
  return _internal_session_type();
}
inline void CIMMsgInfo::_internal_set_session_type(::CIM::Def::CIMSessionType value) {
  
  session_type_ = value;
}
inline void CIMMsgInfo::set_session_type(::CIM::Def::CIMSessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.session_type)
}

// uint64 from_user_id = 6;
inline void CIMMsgInfo::clear_from_user_id() {
  from_user_id_ = uint64_t{0u};
}
inline uint64_t CIMMsgInfo::_internal_from_user_id() const {
  return from_user_id_;
}
inline uint64_t CIMMsgInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.from_user_id)
  return _internal_from_user_id();
}
inline void CIMMsgInfo::_internal_set_from_user_id(uint64_t value) {
  
  from_user_id_ = value;
}
inline void CIMMsgInfo::set_from_user_id(uint64_t value) {
  _internal_set_from_user_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.from_user_id)
}

// uint64 to_session_id = 7;
inline void CIMMsgInfo::clear_to_session_id() {
  to_session_id_ = uint64_t{0u};
}
inline uint64_t CIMMsgInfo::_internal_to_session_id() const {
  return to_session_id_;
}
inline uint64_t CIMMsgInfo::to_session_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.to_session_id)
  return _internal_to_session_id();
}
inline void CIMMsgInfo::_internal_set_to_session_id(uint64_t value) {
  
  to_session_id_ = value;
}
inline void CIMMsgInfo::set_to_session_id(uint64_t value) {
  _internal_set_to_session_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.to_session_id)
}

// uint32 create_time = 8;
inline void CIMMsgInfo::clear_create_time() {
  create_time_ = 0u;
}
inline uint32_t CIMMsgInfo::_internal_create_time() const {
  return create_time_;
}
inline uint32_t CIMMsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.create_time)
  return _internal_create_time();
}
inline void CIMMsgInfo::_internal_set_create_time(uint32_t value) {
  
  create_time_ = value;
}
inline void CIMMsgInfo::set_create_time(uint32_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.create_time)
}

// .CIM.Def.CIMMsgType msg_type = 9;
inline void CIMMsgInfo::clear_msg_type() {
  msg_type_ = 0;
}
inline ::CIM::Def::CIMMsgType CIMMsgInfo::_internal_msg_type() const {
  return static_cast< ::CIM::Def::CIMMsgType >(msg_type_);
}
inline ::CIM::Def::CIMMsgType CIMMsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.msg_type)
  return _internal_msg_type();
}
inline void CIMMsgInfo::_internal_set_msg_type(::CIM::Def::CIMMsgType value) {
  
  msg_type_ = value;
}
inline void CIMMsgInfo::set_msg_type(::CIM::Def::CIMMsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.msg_type)
}

// .CIM.Def.CIMMsgStatus msg_status = 10;
inline void CIMMsgInfo::clear_msg_status() {
  msg_status_ = 0;
}
inline ::CIM::Def::CIMMsgStatus CIMMsgInfo::_internal_msg_status() const {
  return static_cast< ::CIM::Def::CIMMsgStatus >(msg_status_);
}
inline ::CIM::Def::CIMMsgStatus CIMMsgInfo::msg_status() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.msg_status)
  return _internal_msg_status();
}
inline void CIMMsgInfo::_internal_set_msg_status(::CIM::Def::CIMMsgStatus value) {
  
  msg_status_ = value;
}
inline void CIMMsgInfo::set_msg_status(::CIM::Def::CIMMsgStatus value) {
  _internal_set_msg_status(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.msg_status)
}

// bytes msg_data = 11;
inline void CIMMsgInfo::clear_msg_data() {
  msg_data_.ClearToEmpty();
}
inline const std::string& CIMMsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMMsgInfo::set_msg_data(ArgT0&& arg0, ArgT... args) {
 
 msg_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.msg_data)
}
inline std::string* CIMMsgInfo::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMMsgInfo.msg_data)
  return _s;
}
inline const std::string& CIMMsgInfo::_internal_msg_data() const {
  return msg_data_.Get();
}
inline void CIMMsgInfo::_internal_set_msg_data(const std::string& value) {
  
  msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::_internal_mutable_msg_data() {
  
  return msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMMsgInfo.msg_data)
  return msg_data_.Release();
}
inline void CIMMsgInfo::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    
  } else {
    
  }
  msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_data_.IsDefault()) {
    msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMMsgInfo.msg_data)
}

// string attach = 12;
inline void CIMMsgInfo::clear_attach() {
  attach_.ClearToEmpty();
}
inline const std::string& CIMMsgInfo::attach() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.attach)
  return _internal_attach();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMMsgInfo::set_attach(ArgT0&& arg0, ArgT... args) {
 
 attach_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.attach)
}
inline std::string* CIMMsgInfo::mutable_attach() {
  std::string* _s = _internal_mutable_attach();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMMsgInfo.attach)
  return _s;
}
inline const std::string& CIMMsgInfo::_internal_attach() const {
  return attach_.Get();
}
inline void CIMMsgInfo::_internal_set_attach(const std::string& value) {
  
  attach_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::_internal_mutable_attach() {
  
  return attach_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMMsgInfo::release_attach() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMMsgInfo.attach)
  return attach_.Release();
}
inline void CIMMsgInfo::set_allocated_attach(std::string* attach) {
  if (attach != nullptr) {
    
  } else {
    
  }
  attach_.SetAllocated(attach, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attach_.IsDefault()) {
    attach_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMMsgInfo.attach)
}

// .CIM.Def.CIMClientType sender_client_type = 13;
inline void CIMMsgInfo::clear_sender_client_type() {
  sender_client_type_ = 0;
}
inline ::CIM::Def::CIMClientType CIMMsgInfo::_internal_sender_client_type() const {
  return static_cast< ::CIM::Def::CIMClientType >(sender_client_type_);
}
inline ::CIM::Def::CIMClientType CIMMsgInfo::sender_client_type() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMMsgInfo.sender_client_type)
  return _internal_sender_client_type();
}
inline void CIMMsgInfo::_internal_set_sender_client_type(::CIM::Def::CIMClientType value) {
  
  sender_client_type_ = value;
}
inline void CIMMsgInfo::set_sender_client_type(::CIM::Def::CIMClientType value) {
  _internal_set_sender_client_type(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMMsgInfo.sender_client_type)
}

// -------------------------------------------------------------------

// CIMChannelInfo

// string channel_name = 1;
inline void CIMChannelInfo::clear_channel_name() {
  channel_name_.ClearToEmpty();
}
inline const std::string& CIMChannelInfo::channel_name() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMChannelInfo.channel_name)
  return _internal_channel_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMChannelInfo::set_channel_name(ArgT0&& arg0, ArgT... args) {
 
 channel_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMChannelInfo.channel_name)
}
inline std::string* CIMChannelInfo::mutable_channel_name() {
  std::string* _s = _internal_mutable_channel_name();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMChannelInfo.channel_name)
  return _s;
}
inline const std::string& CIMChannelInfo::_internal_channel_name() const {
  return channel_name_.Get();
}
inline void CIMChannelInfo::_internal_set_channel_name(const std::string& value) {
  
  channel_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMChannelInfo::_internal_mutable_channel_name() {
  
  return channel_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMChannelInfo::release_channel_name() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMChannelInfo.channel_name)
  return channel_name_.Release();
}
inline void CIMChannelInfo::set_allocated_channel_name(std::string* channel_name) {
  if (channel_name != nullptr) {
    
  } else {
    
  }
  channel_name_.SetAllocated(channel_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_name_.IsDefault()) {
    channel_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMChannelInfo.channel_name)
}

// string channel_token = 2;
inline void CIMChannelInfo::clear_channel_token() {
  channel_token_.ClearToEmpty();
}
inline const std::string& CIMChannelInfo::channel_token() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMChannelInfo.channel_token)
  return _internal_channel_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CIMChannelInfo::set_channel_token(ArgT0&& arg0, ArgT... args) {
 
 channel_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CIM.Def.CIMChannelInfo.channel_token)
}
inline std::string* CIMChannelInfo::mutable_channel_token() {
  std::string* _s = _internal_mutable_channel_token();
  // @@protoc_insertion_point(field_mutable:CIM.Def.CIMChannelInfo.channel_token)
  return _s;
}
inline const std::string& CIMChannelInfo::_internal_channel_token() const {
  return channel_token_.Get();
}
inline void CIMChannelInfo::_internal_set_channel_token(const std::string& value) {
  
  channel_token_.Set(value, GetArenaForAllocation());
}
inline std::string* CIMChannelInfo::_internal_mutable_channel_token() {
  
  return channel_token_.Mutable(GetArenaForAllocation());
}
inline std::string* CIMChannelInfo::release_channel_token() {
  // @@protoc_insertion_point(field_release:CIM.Def.CIMChannelInfo.channel_token)
  return channel_token_.Release();
}
inline void CIMChannelInfo::set_allocated_channel_token(std::string* channel_token) {
  if (channel_token != nullptr) {
    
  } else {
    
  }
  channel_token_.SetAllocated(channel_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_token_.IsDefault()) {
    channel_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CIM.Def.CIMChannelInfo.channel_token)
}

// uint64 creator_id = 3;
inline void CIMChannelInfo::clear_creator_id() {
  creator_id_ = uint64_t{0u};
}
inline uint64_t CIMChannelInfo::_internal_creator_id() const {
  return creator_id_;
}
inline uint64_t CIMChannelInfo::creator_id() const {
  // @@protoc_insertion_point(field_get:CIM.Def.CIMChannelInfo.creator_id)
  return _internal_creator_id();
}
inline void CIMChannelInfo::_internal_set_creator_id(uint64_t value) {
  
  creator_id_ = value;
}
inline void CIMChannelInfo::set_creator_id(uint64_t value) {
  _internal_set_creator_id(value);
  // @@protoc_insertion_point(field_set:CIM.Def.CIMChannelInfo.creator_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Def
}  // namespace CIM

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CIM::Def::CIMCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMIntenralCmdID> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMErrorCode> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMClientType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMSessionType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMMsgType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMMsgStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMMsgNotificationType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMSessionStatusType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMMsgFeature> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMVoipInviteType> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMInviteRspCode> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMVoipByeReason> : ::std::true_type {};
template <> struct is_proto_enum< ::CIM::Def::CIMResCode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CIM_2eDef_2eproto
